### [1.Leetocde001两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

> 解题思路：HashMap

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 用数组存储之前的数
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        // 对数组进行遍历
        for(int i=0;i<nums.length;i++){

            // 不为空
            if(!hashMap.isEmpty()&&hashMap.containsKey(target-nums[i])){
                int index = hashMap.get(target-nums[i]);
                return new int[]{index,i};
            }else{
                hashMap.put(nums[i],i);
            }

        }
        return new int[]{-1,-1};

    }
}
```

### [2.Leetcode002两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

> 解题思路：求和的模板

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 加法运算
        // 结果
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;
        // 进位
        int flag = 0;
        // 开始遍历 
        while(l1!=null || l2!=null){
            // 判别是否为空
            int v1 = l1==null?0:l1.val;
            int v2 = l2==null?0:l2.val;
            // 相加求和
            int temp_res = v1+v2+flag;

            // 新值赋值
            head.next = new ListNode(temp_res%10);
            head = head.next;
            flag = temp_res/10;

            // 接着走
            if(l1!=null){
                l1 = l1.next;
            }
            if(l2!=null){
                l2 = l2.next;
            }


        }

        if(flag!=0){
            head.next = new ListNode(flag);
        }

        return dummy.next;

    }
}
```

### [3.Leetcode003无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        /**
            1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,
             此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；

            2、如果当前字符 ch 包含在 map中，此时有2类情况：
             1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，
             那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；
             2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，
             而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；
             随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时
             应该不变，left始终为2，子段变成 ba才对。

             为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).
             另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，
             因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！
             */
        char[] arr = s.toCharArray();
        // 重复字符 用hashMap来辅助
        HashMap<Character,Integer> dict = new HashMap<>();
        // 滑动窗口 子串的问题
        int left = 0;
        int right =  0;
       
        // 结果值
        int res = 0;
        while(right<arr.length){
            // 如果包含了
            if(dict.containsKey(arr[right])){
                // 移动left
                left = Math.max(left,dict.get(arr[right])+1);
            }

            dict.put(arr[right],right);

            res = Math.max(res,right-left+1);
            right++;


        }
        return res;

    }
}
```

### [4.Leetcode005最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"

> 解题思路：中心扩散法

```java
class Solution {
    public String longestPalindrome(String s) {
        // 回文字符串  两种扩散方式
        // 一种是  aba 从b往两边
        // 一种是   abba 从bb往两边扩散
        
        // 结果字符串
        String res = "";
        for(int i=0;i<s.length();i++){
            String res_1 = check(s,i,i);
            String res_2 = check(s,i,i+1);
            
            res = res.length()>res_1.length()?res:res_1;
            res = res.length()>res_2.length()?res:res_2;
        }
        return res;
    }

    // 检查
    public String check(String s,int left,int right){
        while(left>=0&&right<=s.length()-1&&s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }

        return s.substring(left+1,right);

    }
}
```

### [5.Leetcode006 Z型变换](https://leetcode-cn.com/problems/zigzag-conversion/)

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);


示例 1：

输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
示例 2：
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I

> 解题思路：考察逻辑

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1){
            return s;
        }
        // 将其转换为数组
        char[] arr = s.toCharArray();
        // 结果数组
        StringBuilder res = new StringBuilder();
        // 按行来求值
        for(int i=0;i<numRows;i++){
            // 对字符串求值
            for(int j=0;j<arr.length;j++){
                // 如果字符串中的索引符合当前行号
                if(j%(2*numRows-2)==i || j%(2*numRows-2)==2*numRows-2-i){
                    res.append(arr[j]);
                }
            }
        }
        return res.toString();
    }
}
```

> 找规律的题目，先安放第一行和最后一行，之后安放中间一行的值，比如1,1+2n*numrows-1还可以安放

```java
class Solution {
    public String convert(String s, int numRows) {
        char[] arr = s.toCharArray();
        int n = s.length();
        
        StringBuilder res = new StringBuilder();
        int cycle = 2*numRows-2;
        // 按行
        for(int i=0;i<numRows;i++){
            // 按列找
            for(int j=0;j+i<n;j+=cycle){
                res.append(arr[j+i]);
                // 不在第一行和最后一行存在了中间值
                if(i!=0&&i!=numRows-1&&j+cycle-i<n){
                    res.append(arr[j+cycle-i]);
                }

            }
        }
        return res.toString();

    }
}
```



### [6.Leetcode007整数翻转](https://leetcode-cn.com/problems/reverse-integer/)

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21

> 解题思路：通过取余和取10来求，并判断是否溢出

```java
class Solution {
    public int reverse(int x) {
        // 不允许存储64位就是不允许用long
        int res = 0;
        while(x!=0){
            // 判断是否溢出
            if(((res*10)/10)!=res){
                res = 0;
                return res;
            }
            res = res*10 + x%10;
            x   = x/10;
        }
        return res;
    }
}
```

### [7.Leetcode008字符串转整数atoi](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

> 解题思路：先去看空格，后看正负号以及是否不是数字，再看数字计算。判断溢出。

```java
class Solution {
    public int myAtoi(String s) {
        int index = 0;
        int n = s.length();
        // 转成数组
        char[] arr = s.toCharArray();

        // 开始丢弃空格
        while(index<n&&arr[index]==' '){
            index++;
        }
        // 如果到头了
        if(index==n){
            return 0;
        }
        // 判断符号
        boolean neg = false;
        if(arr[index]== '-'){
            neg = true;
            index++;
        }else if(arr[index]=='+'){
            index++;
        }else if(!Character.isDigit(arr[index])){
            //遇到不是数字的字符
            return 0;
        }

        // 存储结果
        int res = 0;
        // 判断长度和是否是数字以及是否超出
        while(index<n&&Character.isDigit(arr[index])){
            int digit = arr[index]-'0';
            //判断是否溢出 res*10+digit>Integer.MAX_VALUE 即res>
            if(res>(Integer.MAX_VALUE-digit)/10){
                return neg?Integer.MIN_VALUE:Integer.MAX_VALUE;
            }

            res = res*10 + digit;
            index++;
            
        }
        return neg?-res:res;

    }
}
```



### [8.Leetcode009回文数](https://leetcode-cn.com/problems/palindrome-number/)

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

 

示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

> 翻转数字后比较是否相等

```java
class Solution {
    public boolean isPalindrome(int x) {
        // 判断回文数字->翻转数字 来判断值
        if(x<0){
            return false;
        }
        // 对其翻转
        int verse_digit = 0;
        int temp = x;
        while(temp!=0){
            verse_digit = verse_digit*10 + temp%10;
            temp = temp/10;
        }

        return verse_digit==x?true:false;

    }
}
```

### [9.Leetcode011盛最多的水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

 

示例 1：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

> 解题思路：用双指针的思路

```java
class Solution {
    public int maxArea(int[] height) {
        // 两个指针 
        int left = 0;
        int right = height.length-1;
        // 结果
        int res = 0;
        // 同时出发
        while(left<right){
            int temp = Math.min(height[left],height[right])*(right-left);
            res = Math.max(temp,res);
            // 如何走
            if(height[left]>=height[right]){
                right--;
            }else{
                left++;
            }

        }
        return res;


    }
}
```

### [10.Leetcode013罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

> 解题思路一、用hashmap来解题

```java
class Solution {
    public int romanToInt(String s) {
        // 字符串转罗马数字，一个办法是用hashMap来存储
        Map<String,Integer> hashMap = new HashMap<>();
        hashMap.put("I",1);
        hashMap.put("IV",4);
        hashMap.put("V",5);
        hashMap.put("IX",9);
        hashMap.put("X",10);
        hashMap.put("XL",40);
        hashMap.put("L",50);
        hashMap.put("XC",90);
        hashMap.put("C",100);
        hashMap.put("CD",400);
        hashMap.put("D",500);
        hashMap.put("CM",900);
        hashMap.put("M",1000);

        int res = 0;
        // 对其遍历
        for(int i=0;i<s.length();){
            if(i+1<s.length()&&hashMap.containsKey(s.substring(i,i+2))){
                //两个字符
                res += hashMap.get(s.substring(i,i+2));
                i+=2;
            }else{
                // 一个字符
                res += hashMap.get(s.substring(i,i+1));
                i++;
            }
        }

        return res;
    }
}
```

> 解题思路：利用hahsmap建立符合和值之间的映射，之后将字符串从左到右来计算，如果当前字符与前一个字符进行比较，如果不小于前一个字符，则相加；若大于减去前一个字符。

```JAVA
class Solution {
    public int romanToInt(String s) {
        if(s==null||s.length()<1){
            return 0;
        }
        // 对其存储
        HashMap<Character,Integer> hashMap = new HashMap<>(){{
            put('I',1);
            put('V',5);
            put('X',10);
            put('L',50);
            put('C',100);
            put('D',500);
            put('M',1000);
        }};
        // 结果
        int res = 0;
        // 字符串转换
        char[] arr = s.toCharArray();
        // 对其遍历
        int preNum = hashMap.get(arr[0]);
        for(int i=1;i<arr.length;i++){
            int curNum = hashMap.get(arr[i]);
            // 比较
            if(preNum>=curNum){
                res += preNum;
            }else{
                res -= preNum;
            }
            preNum = curNum;
        }
        res += preNum;
        return res;
    }
}
```

> 那么如何将一个整数转换为罗马数字，其数字范围为1-3999之间。

```java
class Solution {
    public String intToRoman(int num) {
        // 数值
        int[] digit     =     {1000,900,500,400,100,90,50,40,10,9,5,4,1};
        // 字符
        String[] symbols =    {"M","CM", "D","CD", "C","XC", "L","XL", "X","IX","V","IV","I"};
        // 结果
        StringBuilder res = new StringBuilder();
        // 对数值进行遍历
        for(int i=0;i<digit.length;i++){
            while(num>=digit[i]){
                res.append(symbols[i]);
                num -= digit[i];
            }
        }
        return res.toString();
    }
}
```

### [11.Leetcode014最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 

示例 1：

输入：strs = ["flower","flow","flight"]
输出："fl"
示例 2：

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。

> 解题思路：第一重for循环对第一个，第二个for循环循环其余字符串

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length<1){
            return "";
        }
        // 第一个作为模板
        int count = strs.length;
        // 第一个的长度
        int length = strs[0].length();
        // 对第一个进行遍历
        for(int i=0;i<length;i++){
            char c = strs[0].charAt(i);
            // 与另外两个对比
            for(int j=1;j<count;j++){
                // 不相等就返回
                if(i==strs[j].length()||c!=strs[j].charAt(i)){
                    return strs[0].substring(0,i);
                }
            }
        }
        // 只有一个数
        return strs[0];
    }
}
```

### [12.Leetcode015三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]

> 解题思路：排序+for循环+双指针+去重+剪枝

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 先排序
        Arrays.sort(nums);
        // 结果存储
        List<List<Integer>> res = new ArrayList<>();
        // 后for循环+双指针
        for(int i=0;i<nums.length-2;i++){

            // 去重
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }

            //剪枝
            int maxNum = nums[i] + nums[nums.length-1] + nums[nums.length-2];
            if(maxNum<0){
                continue;
            }
            int minNum = nums[i] + nums[i+1] + nums[i+2];
            if(minNum>0){
                break;
            }

            
            int left = i+1;
            int right = nums.length-1;
            // 循环
            while(left<right){
                // 当前值
                int curNum = nums[i] + nums[left] + nums[right];
                if(curNum==0){
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[left]);
                    temp.add(nums[right]);
                    res.add(temp);
                    // 满足条件的话如何移动
                    // 去重的移动
                    while(left<right&&nums[left+1]==nums[left]){
                        left++;
                    }
                    left++;
                    while(left<right&&nums[right]==nums[right-1]){
                        right--;
                    }
                    right--;

                }else if(curNum>0){
                    right--;
                }else if(curNum<0){
                    left++;
                }
            }
        }
        return res;
    }
}
```

### [13.Leetcode016最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

 

示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

> 解题思路：排序+双指针，难点在于如何衡量距离，利用abs，计算前一个与target的距离与后一个与target的距离

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        // 排序
        Arrays.sort(nums);
        // 结果
        int closeNum = nums[0]+nums[1]+nums[2];
        
        // 第一重for循环
        for(int i=0;i<nums.length-2;i++){
            // 左指针
            int left = i+1;
            int right = nums.length-1;
            while(left<right){
                
                // 当前值
                int curNum = nums[i] + nums[left] + nums[right];

                // 记录最接近的值
                if(Math.abs(curNum-target)<Math.abs(closeNum-target)){
                    closeNum = curNum;
                }

                if(curNum==target){
                    return curNum;
                }else if(curNum>target){
                    right--;
                }else if(curNum<target){
                    left++;    
                }
            }
        }
        return closeNum;
    }
}
```

### [14.Leetcode019删除链表的倒数第N个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

 ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

示例 1：


输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

> 解决思路：整体不难，但是重点在于边界值。这里通过设置一个哑结点，就可以解决这个问题。要不然通过该测试。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 增加一个哑结点即可
        ListNode dummy = new ListNode(-1,head);
        // 两个头指针
        ListNode fast = dummy;
        ListNode slow = dummy;
        // 开始走
        for(int i=1;i<=n;i++){
            fast = fast.next;
        }
    
        // 一起走
        while(fast.next!=null){
            slow = slow.next;
            fast = fast.next;
        }
        // 找到了待删的前一个
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

### [15.Leeetcode020有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。


示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false

> 解题思路：考察hashmap和栈的用法

```java
class Solution {
    public boolean isValid(String s) {
        // 考察栈
        HashMap<Character,Character> hasHMap = new HashMap<>();
        hasHMap.put(')','(');
        hasHMap.put('}','{');
        hasHMap.put(']','[');
        Stack<Character> stack = new Stack<>();
        // 字符串
        char[] arr = s.toCharArray();
        // 对其遍历
        for(int i=0;i<arr.length;i++){
            /// 如果是右括号，
            if(hasHMap.containsKey(arr[i])){
                // 栈为空
                if(stack.isEmpty() || stack.pop()!=hasHMap.get(arr[i])){
                    return false;
                }
            }else{
                // 如果是左括号直接入栈
                stack.push(arr[i]);
            }
        }
        // 判断
        if(stack.isEmpty()){
            return true;
        }
        return false;
    }
}
```

### [16.Leetcode021合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

> 解题思路：哑结点的思路

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //合并两个链表
        ListNode merge_head = new ListNode(-1);
        ListNode l = merge_head;
        // 对其遍历
        while(l1!=null&&l2!=null){
            // 比较
            if(l1.val<=l2.val){
                l.next = new ListNode(l1.val);
                l1 = l1.next;
            }else{
                l.next = new ListNode(l2.val);
                l2 = l2.next;
            }
            l = l.next;
        }
        // 未遍历完
        if(l1!=null){
            l.next = l1;
        }
        if(l2!=null){
            l.next = l2;
        }
        return merge_head.next;

    }
}
```

### [17.Leetcode022括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：

输入：n = 1
输出：["()"]

> 解题思路：递归的思路，left表示左括号剩余个数，right表示右括号剩余个数

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        // 解题思路：递归
        getParenthesis("",n,n);
        return res;
    }
    // left表示左括号 right表示右括号
    public void getParenthesis(String str,int left,int right){
        if(left==0&&right==0){
            res.add(str);
            return;
        }
        // 左括号不能剩余的右括号多
        if(left>right){
            return;
        }
        // 其余递归
        if(left>0){
            getParenthesis(str+"(",left-1,right);
        }

        if(right>0){
            getParenthesis(str+")",left,right-1);
        }

    }
}
```

### [18.Leetcode023合并 K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

> 解题思路：优先级队列，最小堆。如果有空，则不入，注意这一点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    
    public ListNode mergeKLists(ListNode[] lists) {
        // 合并K个升序链表，topK问题，用优先级队列 自定义排序 建立最小
        PriorityQueue<ListNode> queue = new PriorityQueue<>((l1,l2)->(l1.val-l2.val));
       //对其存入值
       for(int i=0;i<lists.length;i++){
           // 判断是否为空
           if(lists[i]!=null){
             queue.offer(lists[i]);
           }
       }
       // 结果
       ListNode dummy = new ListNode(-1);
       ListNode head  = dummy;
       // 对其遍历
       while(!queue.isEmpty()){
           // 建立新节点
           ListNode curNode = queue.poll();
           head.next = new ListNode(curNode.val);
           head = head.next;
           // 排出来的这个节点是否还有
           if(curNode.next!=null){
               curNode = curNode.next;
               queue.offer(curNode);
           }
       }
       return dummy.next;
    }
}
```

### [19.Leetcode024两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

> 解题思路：将其看成荷兰国旗问题，维持一个区间，区间的后面两个交换，符合条件的加入进来

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
       ListNode dummy = new ListNode(-1,head);
       ListNode newHead = dummy;
       while(newHead.next!=null&&newHead.next.next!=null){
           ListNode node1 = newHead.next;
           ListNode node2 = newHead.next.next;
           // 连接
           node1.next = node2.next;
           newHead.next = node2;
           node2.next = node1;
           // 移动到node1的位置
           newHead = node1;
       }
       return dummy.next; 
    }
}
```

### [20.Leetcode025K个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：

你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

> 解题思路：不同于上面，两两交换，这个是翻转！！！
>
> 思路还是将其分成k段，每一段单独处理，翻转。注意的是还是左边是已排序好的，右边是未排序好的。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 分段
        ListNode dummy = new ListNode(-1,head);
        // 给出一个头一个尾巴
        ListNode pre = dummy;
        ListNode tail = dummy;
        while(pre!=null){
            // 先走k
            for(int i=0;i<k;i++){
                tail = tail.next;
                if(tail==null){
                    return dummy.next;
                }
            }
            //对其每段的记录
            ListNode start = pre.next;
            ListNode end = tail.next;
            // k断开
            tail.next = null;
            // 新链表连接上
            pre.next = reverse(start);
            // k断开重连
            start.next = end;
            pre = start;
            tail = start;

        }
        return dummy.next;
    }

    // 给一个头结点翻转出
    public ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode next = null;
        while(head!=null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```

### [21.Leetcode26删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

> 旧数组与新数组，相等就＋，不相等则处理

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 新数组中的索引是从0开始的
        int left = 0;
        // 旧数组中的索引是从1开始的
        int right = 1;
        // 就数组遍历
        while(right<nums.length){
            // 相等
            if(nums[right]==nums[left]){
                right++;
            }else{
                // 不相等了
                nums[++left] = nums[right++];
            }
        }
        // 返回长度
        return left+1;
    }
    
    
}
```

### [22.Leetcode031下一个排列](https://leetcode-cn.com/problems/next-permutation/)

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

 

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]

示例 4：

输入：nums = [1]
输出：[1]

> 解题思路：从左到大找第二个大的 在前一个的基础上找比其大的
>
> 如果已经是最大的，重新排序即可

```java
class Solution {
    public void nextPermutation(int[] nums) {
        // 例如1 2 3 4 5 下一个更大的是 1 2 3 5 4
        int l = 0;
        int r = nums.length-1;
        // 第一次遍历查找
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]<nums[i+1]){
                l = i;
            }
        }
        // 第二次基于第一个的基础上
        for(int j=l+1;j<nums.length;j++){
            if(nums[j]>nums[l]){
                r = j;
            }
        }

        // 交换
        int temp = nums[l];
        nums[l]  = nums[r];
        nums[r]  = temp;

        // 排序 如果是最大值了，重新排序
        Arrays.sort(nums,l+1,nums.length);
    }
}
```

### [23.Leetcode033搜索旋转数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

示例 3：

输入：nums = [1], target = 0
输出：-1

> 解题思路：通过二分查找，先通过判断

```java
class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums,target);
    }

    // 二分查找
    public int binarySearch(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left + ((right-left)>>1);
            // 判断
            if(nums[mid]==target){
                return mid;
            }

            if(nums[mid]>=nums[left]){
                // 左边有序
                if(nums[left]<=target&&target<nums[mid]){
                    right = mid-1;
                }else{
                    left = mid + 1;
                }
            }else{
                // 右边有序
                if(nums[mid]<target&&target<=nums[right]){
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }
        }
        return -1;
    }
}
```

### [24.Leetcode46全排列](https://leetcode-cn.com/problems/permutations/)

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

> 解题思路：dfs 子集 排列 组合

```java
class Solution {
    // 结果
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        // 遍历过了
        boolean[] visited = new boolean[nums.length];
        // 对其回溯
        // 临时值
        List<Integer> list = new ArrayList<>();
        dfs(nums,list,visited);
        return res;
    }

    // 全部都遍历一遍
    public void dfs(int[] nums,List<Integer> list,boolean[] visited){
        if(list.size()==nums.length){
            res.add(new ArrayList<>(list));
            return;
        }

        for(int i=0;i<nums.length;i++){
            if(visited[i]==true){
                // 遍历过一遍了
                continue;
            }
            
            visited[i] = true;
            list.add(nums[i]);

            dfs(nums,list,visited);
            
            visited[i] = false;
            list.remove(list.size()-1);

        }

    }
}
```

### [25.Leetcode53最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：

输入：nums = [1]
输出：1

示例 3：

输入：nums = [0]
输出：0

> 解题思路：动态规划

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // 最大子序和 用动态规划的思路
        int[] dp = new int[nums.length];
        int maxValue = nums[0];
        dp[0] = nums[0];
        // 遍历
        for(int i=1;i<nums.length;i++){
            // 转移方程最大值 要不就是当前值 要不就是前一个+当前值
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
            maxValue = Math.max(maxValue,dp[i]);
        }
        return maxValue;
    }
}
```

### [26.Leetcode055跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

> 贪心算法：维护一个最远能达到的长度

```java
class Solution {
    public boolean canJump(int[] nums) {
        
        // 贪心算法，看其最大的跳跃长度
        int maxLen = nums[0];
        for(int i=0;i<nums.length;i++){
            // 可以访问的长度
            if(i<=maxLen){
                // 更新
                maxLen = Math.max(maxLen,i+nums[i]);
                // 走到最后一个即可
                if(maxLen>=nums.length-1){
                    return true;
                }
            }
        }
        return false;
        
    }
}
```

### [27.Leetcode056合并区间](https://leetcode-cn.com/problems/merge-intervals/)

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

> 解题思路：先对其自定义排序，然后合并

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 对其自定义排序
        Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
        // 用List来存储 
        List<int[]> list = new  ArrayList<>();
        //对其遍历
        for(int i=0;i<intervals.length;i++){
            // 如果为空
            if(list.isEmpty()){
                list.add(new int[]{intervals[i][0],intervals[i][1]});
            }else{
                // 不为空
                if(list.get(list.size()-1)[1]>=intervals[i][0]){
                    // 可以整合
                    // list.get(list.size()-1)[0] = Math.min(list.get(list.size()-1)[0],intervals[i][0]);
                    list.get(list.size()-1)[1] = Math.max(list.get(list.size()-1)[1],intervals[i][1]);
                }else{
                    // 不可以整合
                    list.add(new int[]{intervals[i][0],intervals[i][1]});
                }
            }
        }

        return list.toArray(new int[list.size()][]);
    }
}
```

### [28.Leetcode062不同路径](https://leetcode-cn.com/problems/unique-paths/)


一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？



**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

> 解题思路：动态规划 定义 初始化 转移方程。

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 动态规划解题思路
        // 开辟数组
        int[][] dp = new int[m][n];
        // 初始化
        for(int i=0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int j=0;j<n;j++){
            dp[0][j] = 1;
        }
        // 其余值
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                // 转移方程计算总共路径
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        // 最后的结果值
        return dp[m-1][n-1];
    }
}
```

### [29.Leetcode069 x的平方根](https://leetcode-cn.com/problems/sqrtx/)

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2

示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

> 二分查找

```java
class Solution {
    public int mySqrt(int x) {
        if(x==0||x==1){
            return x;
        }
        // 二分查找
        return binarySearch(x);
    }
    // 二分查找
    public int binarySearch(int x){
        double left = 0;
        double right = x;
        double mid = left + (right-left)/2;
        while(Math.abs(mid*mid-x)>(Math.pow(10,-6))){
            mid = left + (right-left)/2;
            if(mid*mid>x){
                right = mid;
            }else if(mid*mid<x){
                left = mid;
            }
        } 
        return (int)mid;

    }
}
```

> 牛顿迭代法：注意数据类型用long

```java
class Solution {
    public int mySqrt(int x) {
        // 牛顿迭代法
        long n = x;
        while(n*n>x){
            n = (n+x/n)/2;
        }
        return (int)n;
    }
}
```



### [30.Leetcode070爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/submissions/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

> 递归解法超时

```java
class Solution {
    public int climbStairs(int n) {
        // 爬楼梯
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        return climbStairs(n-1)+climbStairs(n-2);
    }
}
```



```java
class Solution {
    public int climbStairs(int n) {
        // 爬楼梯
        if(n<=2){
            return n;
        }

        // 对其遍历
        int f1 = 1;
        int f2 = 2;
        int f = f1+f2;
        int index = 3;
        while(index<=n){
            f = f1+f2;
            f1 = f2;
            f2 = f;
            index++;
        }

        return f;
    }
}
```

### [31.Leetcode078子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：

输入：nums = [0]
输出：[[],[0]]

> 回溯的解法

```java
class Solution {
    // 子集
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        // 临时值
        List<Integer> list = new ArrayList<>();
        dfs(nums,0,list);
        return res;
    }
    // 回溯
    public void dfs(int[] nums,int index,List<Integer> list){
        res.add(new ArrayList<>(list));

        for(int i=index;i<nums.length;i++){
            list.add(nums[i]);
            dfs(nums,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

### [32.Leetcode079单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false

> 解题思路：dfs 上下左右走

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        // string转数组
        char[] word_arr = word.toCharArray();
        // 对其遍历
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(dfs(board,word_arr,i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }

    // dfs 上下左右走
    public boolean dfs(char[][] board,char[] word_arr,int i,int j,int index){
        // 递归截止条件
        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j]!=word_arr[index]){
            return false;
        }
        // 遍历到最后一个了
        if(index==word_arr.length-1){
            return true;
        }
        // 记录当前值已被遍历到了
        char temp = board[i][j];
        board[i][j] = '0';

        // 结果值
        boolean res = dfs(board,word_arr,i-1,j,index+1) || 
                      dfs(board,word_arr,i+1,j,index+1) || 
                      dfs(board,word_arr,i,j-1,index+1) || 
                      dfs(board,word_arr,i,j+1,index+1);
        // 回溯
        board[i][j] = temp;

        return res;
    }
}
```

### [33.Leetcode082删除排序链表中的重复元素II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:

输入: 1->1->1->2->3
输出: 2->3

> 解题思路：快慢指针
>
> 删除全部重复是while  -if while
>
> 保留一个重复的是 while while

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // 哑结点
        ListNode dummy = new ListNode(-1,head);
        // 快慢指针
        ListNode slow = dummy;
        ListNode fast = head;
        // 开始
        while(fast!=null){
            // 遇到重复了
            if(fast.next!=null&&fast.val==fast.next.val){
                // 多走几步
                while(fast.next!=null&&fast.val==fast.next.val){
                    fast = fast.next;
                }
                fast = fast.next;
                slow.next = fast;
            }else{
                // 不重复了
                slow = slow.next;
                fast = fast.next;
            }

        }

        return dummy.next;
    }
}
```



> 额外的一题
>
> [Leetcode083删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
>
> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
>
> 示例 1:
>
> 输入: 1->1->2
> 输出: 1->2
> 示例 2:
>
> 输入: 1->1->2->3->3
> 输出: 1->2->3

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // 删除排序链表中的重复元素
        // 哑结点
        ListNode dummy = new ListNode(-1,head);
        // 快慢指针
        ListNode slow = dummy;
        ListNode fast  = dummy;
        // 开始
        while(fast!=null){
            // 如果重复了
            while(fast!=null&&slow.val==fast.val){
                fast = fast.next;
            }
            slow.next = fast;
            slow = slow.next;
            // 继续
            if(fast!=null){
                fast = fast.next;
            }
        }
        return dummy.next;
    }
}
```

### [34.Leetcode083删除排序链表](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1->1->2
输出: 1->2
示例 2:

输入: 1->1->2->3->3
输出: 1->2->3

> 解题思路：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // 哑结点
        ListNode dummy = new ListNode(-1,head);
        // 快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null){
            // 如果重复的了
            while(fast!=null&&slow.val==fast.val){
                fast = fast.next;
            }
            slow.next = fast;
            slow  = slow.next;
        }
        return dummy.next;
    }
}
```

### [35.Leetcode086分割链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)


输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]

> 解题思路：链表不像数组，那样可以原地交换。所以需要开辟两个链表的空间

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        // 两个链表来维护一个大的一个小的
        ListNode smallDummy = new ListNode(-1,head);
        ListNode small = smallDummy;
        ListNode bigDummy = new ListNode(-1,head);
        ListNode big = bigDummy;
        // 对其遍历
        while(head!=null){
            if(head.val<x){
                small.next = head;
                small = small.next;
            }else if(head.val>=x){
                big.next = head;
                big  = big.next;
            }
            head = head.next;
        }
        // 拼接
        big.next = null;
        small.next = bigDummy.next;
        return smallDummy.next;

    }
}
```

### [36.Leetcode088合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

 

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]

示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]

> 原地修改数组，逆序

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 在数组1中保存数组2，那么就逆序来看
        int index1 = m-1;
        int index2 = n-1;
        int index = m+n-1;
        // 开始遍历
        while(index1>=0&&index2>=0){
            // 开始判断
            if(nums1[index1]>=nums2[index2]){
                nums1[index] = nums1[index1];
                index1--;
                index--;
            }else if(nums1[index1]<nums2[index2]){
                nums1[index] = nums2[index2];
                index2--;
                index--;
            }
        }
        // 如果nums2还有剩余
        while(index2>=0){
            nums1[index--] = nums2[index2--];
        }
        
    }
}
```

### [37.Leetcode092反转链表II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL

> 第一个for循环找到该处
>
> 第二个for循环翻转
>
> 第三个连接

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 开始
        ListNode dummy = new ListNode(-1,head);
        // 指针
        ListNode newHead = dummy;
        // 先走
        for(int i=1;i<left;i++){
            newHead = newHead.next;
        }
        //翻转
        ListNode cur = newHead.next;
        ListNode pre = null;
        ListNode next = null;
        // 翻转停止条件
        for(int i=left;i<=right;i++){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        // 此时cur为指向的下一个 
        // 重新串联起来
        newHead.next.next = cur;
        newHead.next = pre;
        return dummy.next;
    }
}
```

### [38.Leetcode93复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

 

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]

> 回溯解题

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        // 临时存储结果
        int[] arr = new int[4];
        // 一个是s的开端 一个是arr的开端
        dfs(s,arr,0,0);
        return res;
    }
    // 回溯
    public void dfs(String s,int[] arr,int s_start,int arr_start){
        // 如果 都遍历到最后了
        if(arr_start==arr.length){
            if(s_start==s.length()){
                // 开始转换
                StringBuilder temp = new StringBuilder();
                //
                for(int i=0;i<arr.length;i++){
                    temp.append(arr[i]);
                    if(i!=arr.length-1){
                        temp.append(".");
                    }
                }
                res.add(temp.toString());
            }
            return;
        }
        // 其他截至条件
        if(s_start==s.length()){
            return;
        }

        // 如果是0的话
        if(s.charAt(s_start)=='0'){
            arr[arr_start] = 0;
            dfs(s,arr,s_start+1,arr_start+1);
        }        
        // 遍历
        // 数字
        int digit = 0;
        for(int i=s_start;i<s.length();i++){
            digit = digit*10 + (s.charAt(i)-'0');
            // 符合条件
            if(digit>0&&digit<=0xFF){
                arr[arr_start] = digit;
                dfs(s,arr,i+1,arr_start+1);
            }else{
                break;
            }
        }

    }
}
```

### [39.Leetcode094二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

> 递归解决方法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        // 递归截止条件
        if(root==null){
            return res;
        }
        // 中序遍历 左 根 右
        inorderTraversal(root.left);
        res.add(root.val);
        inorderTraversal(root.right);
        
        return res;
    }
}
```

> 非递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
       // 非递归的解决方法
       Stack<TreeNode> stack = new Stack<>();
       while(!stack.isEmpty() || root!=null){
           if(root!=null){
               stack.push(root);
               root = root.left;
           }else{
               root = stack.pop();
               res.add(root.val);
               root = root.right;
           }
       }
       return res;
    }
}
```

### [40.Leetcode098验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

> 解题思路：二叉搜索树搜索中序遍历为升序的，所以用中序遍历的思路去解题 即判断其是否为升序

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 解题思路：中序遍历
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        // 中序遍历 左根右
        if(!isValidBST(root.left)){
            return false;
        }

        if(root.val<=pre){
            return false;
        }
        pre = root.val;

        return isValidBST(root.right);

    }
    
}
```

> 非递归形式 即设置一个最小的前缀，从栈出来的值比其小就false

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        // 用栈来解题
        long pre = Long.MIN_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root!=null){
            if(root!=null){
                stack.push(root);
                root = root.left;
            }else{
                root = stack.pop();
                if(pre!=Long.MIN_VALUE&&root.val<=pre){
                    return false;
                }
                // 赋值
                pre = root.val;
                root = root.right;
            }
        }
        return true;


    }
}
```

### [41.Leetcode101对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

1

   / \
  2   2
 / \ / \
3  4 4  3


但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

1

   / \
  2   2
   \   \
   3    3

> 解题思路：用递归的思路，左右子树，两课子树的判断

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
       if(root==null){
           return true;
       }
       // 分成两个子树来判断
       return isValid(root.left,root.right);
    }
    // 递归解题
    public boolean isValid(TreeNode left,TreeNode right){
        if(left==null&&right==null){
            return true;
        }

        if(left==null || right==null){
            return false;
        }

        if(left.val !=right.val){
            return false;
        }
        return isValid(left.left,right.right)&&isValid(left.right,right.left);
        

    }
    
}
```

> 还是可以从遍历的角度来看，用层序遍历来解题

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null){
            return true;
        }
        // 两课子树
        return isValid(root.left,root.right);
    }
    // 判断其是否是对称二叉树
    public boolean isValid(TreeNode l,TreeNode r){
        //层序遍历
        Queue<TreeNode> q1 = new LinkedList<>();
        Queue<TreeNode> q2 = new LinkedList<>();
        q1.offer(l);
        q2.offer(r);
        while(!q1.isEmpty()&&!q2.isEmpty()){
            l = q1.poll();
            r = q2.poll();
            // 对其判断
            if(l==null&&r==null){
                continue;
            }

            if(l==null||r==null){
                return false;
            }
            
            if(l.val!=r.val){
                return false;
            }
            // 直接入队列
            q1.offer(l.left);
            q2.offer(r.right);


            q1.offer(l.right);
            q2.offer(r.left);

        }
        return true;


    }


}
```

### [42.Leetcode102二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

示例：
二叉树：[3,9,20,null,null,15,7],

3

   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

> 层序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 层序遍历
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        // 每一层的存储
        List<Integer> list = new ArrayList<>();
        // 队列来辅助
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        // 每一层的结点数
        int levelSize = 1;
        while(!queue.isEmpty()){
            root = queue.poll();
            levelSize--;
            list.add(root.val);

            if(root.left!=null){
                queue.offer(root.left);
            }

            if(root.right!=null){
                queue.offer(root.right);
            }

            // 层数为0
            if(levelSize==0){
                res.add(list);
                levelSize = queue.size();
                list = new ArrayList<>();

            }
        }
        return res;
    }
}
```

### [43.Leetcode103 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]

> 解题思路：用层序遍历，加个判断，翻转数组即可

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        // 队列辅助
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int levelSize = 1;
        int index  = 1;
        // 临时存储
        List<Integer> list = new ArrayList<>();
        while(!queue.isEmpty()){
            root = queue.poll();
            levelSize--;
            list.add(root.val);

            if(root.left!=null){
                queue.offer(root.left);
            }

            if(root.right!=null){
                queue.offer(root.right);
            }

            if(levelSize==0){
                if(index%2==0){
                    Collections.reverse(list);
                }
                res.add(new ArrayList<>(list));
                index++;
                levelSize = queue.size();
                list = new ArrayList<>();
            }
        }
        return res;

    }
}
```

### [44.Leetcode104二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

3

   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

> 解题思路：递归或者层序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        // 递归
        if(root==null){
            return 0;
        }
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### [45.Leetcode105从前序与中序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

3

   / \
  9  20
    /  \
   15   7

> 解题思路：递归+hahsMap

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    HashMap<Integer,Integer> hashMap = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 对中序存储
        for(int i=0;i<inorder.length;i++){
            hashMap.put(inorder[i],i);
        }
        return buildMyTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    // 对其构建
    public TreeNode buildMyTree(int[] preorder,int preorder_left,int preorder_right,int[] inorder,int inorder_left,int inorder_right){
        // 递归结束条件
        if(inorder_right<inorder_left){
            return null;
        }
        // 找根节点
        int root_value = preorder[preorder_left];
        // 构建根节点
        TreeNode root = new TreeNode(root_value);
        // 在中序遍历中
        int inorder_root = hashMap.get(root_value);
        // 长度
        int left_size = inorder_root - inorder_left;

        // 递归构建
        root.left = buildMyTree(preorder,preorder_left+1,preorder_left+left_size,inorder,inorder_left,inorder_root-1);
        root.right = buildMyTree(preorder,preorder_left+left_size+1,preorder_right,inorder,inorder_root+1,inorder_right);

        return root;

    }
}
```

### [46.Leetcode112路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

 ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

示例 1：


输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true

> 递归的思路：一个结点 没有结点的时候

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    int sum = 0;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        
        // 一个结点
        if(root.left==null && root.right==null){
            return root.val == targetSum;
        }

        // 其余结点
        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);

    }
}
```

> 层序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        // 层序遍历用两个队列 一个存储从根到该结点的大小
        Queue<TreeNode> q1 = new LinkedList<>();
        Queue<Integer> q2 = new LinkedList<>();
        q1.offer(root);
        q2.offer(root.val);
        // 开始
        while(!q1.isEmpty()){
            root = q1.poll();
            int temp = q2.poll();
            // 遍历到叶子结点了
            if(root.left==null && root.right==null){
                if(temp==targetSum){
                    return true;
                }
                continue;
            }

            if(root.left!=null){
                q1.offer(root.left);
                q2.offer(temp+root.left.val);
            }

            if(root.right!=null){
                q1.offer(root.right);
                q2.offer(temp+root.right.val);
            }
        }
        return false;
    }
}
```

### [47.Leetcode113路径总和II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

> 递归 dfs来解题

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null){
            return res;
        }
        // 临时值
        int target = 0;
        List<Integer> list = new ArrayList<>();
        dfs(root,targetSum,list,target);
        return res;
    }

    public void dfs(TreeNode root,int targetSum,List<Integer> list,int target){
        // 截止条件
        if(root==null){
            return; 
        }
        // 前序遍历
        list.add(root.val);
        target += root.val;
        if(root.left==null&&root.right==null&&target==targetSum){
            res.add(new ArrayList<>(list));
        }
        dfs(root.left,targetSum,list,target);
        dfs(root.right,targetSum,list,target);

        target-=root.val;
        list.remove(list.size()-1);



    }
}
```

> 层次遍历来解题
>
> 两个队列 
>
> 一个hashmap

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // HashMap
    HashMap<TreeNode,TreeNode> hashMap = new HashMap<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        
        // 结果存储
        List<List<Integer>> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        // 队列辅助
        Queue<TreeNode> q1 = new LinkedList<>();
        Queue<Integer> q2 = new LinkedList<>();
        q1.offer(root);
        q2.offer(root.val);
        while(!q1.isEmpty()){
            root = q1.poll();
            int temp = q2.poll();

            // 根节点了
            if(root.left==null&&root.right==null){
                if(temp==targetSum){
                    res.add(buildPath(root));
                }
            }

            if(root.left!=null){
                q1.offer(root.left);
                q2.offer(temp+root.left.val);
                hashMap.put(root.left,root);
            }

            if(root.right!=null){
                q1.offer(root.right);
                q2.offer(temp+root.right.val);
                hashMap.put(root.right,root);
            }
        }
        return res;
    }

    public List<Integer>  buildPath(TreeNode root){
        // 临时值
        List<Integer> list = new ArrayList<>();
        while(root!=null){
            list.add(root.val);
            root = hashMap.get(root);
        }
        //翻转
        Collections.reverse(list);
        return list;
    }
}
```

### [48.Leetcode114二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

> 先对其前序遍历，存储结点，之后对结点的左右进行重排即可

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if(root==null){
            return;
        }
       // 前序遍历展开
       Stack<TreeNode> stack = new Stack<>();
       // 存储结点
       List<TreeNode> list = new LinkedList<>();
       // 对其前序遍历
       stack.push(root);
       while(!stack.isEmpty()){
           root = stack.pop();
            list.add(root);

            if(root.right!=null){
                stack.push(root.right);
            }

            if(root.left!=null){
                stack.push(root.left);
            }
       }

       // 对链表进行操作
       for(int i=1;i<list.size();i++){
           TreeNode cur = list.get(i);
           TreeNode prev = list.get(i-1);
           prev.left = null;
           prev.right = cur;
       }

    }
}
```

> 股票买卖问题-动态规划
>
> 一方面是k=1 k=2 k=无限制 k=？这类题目是 天数 持有未持有 交易次数k
>
> 一方面是手续费，类似上面同
>
> 一方面是冷冻期，即多个个状态 持有 未持有冷冻 未持有不冷冻期

### [49.Leetcode121买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

> 维护一个最小值，计算最大利润即可了

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 维护当前值 之前的最小值
        int minPrice = prices[0];
        // 最大利润
        int maxProfit = 0;
        // 对其遍历
        for(int i=1;i<prices.length;i++){
            maxProfit = Math.max(maxProfit,prices[i]-minPrice);
            minPrice = Math.min(minPrice,prices[i]);
        }
        return maxProfit;
    }
}
```

### [50.Leetcode122买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

> 可以进行多次买卖。
>
> 解题思路：动态规划 股票有两个状态，一个是未持有 一个是持有。

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 解题思路 当天股票存在两个状态 一个是未持有 一个是持有状态
        int dp0 = 0;
        int dp1 = -prices[0];
        // 对其遍历
        for(int i=1;i<prices.length;i++){
            // 之后一天的未持有 前一天未持有 前一天持有了 今儿卖了			
            dp0 = Math.max(dp0,dp1+prices[i]);
            // 之后一天的持有 前一天未持有 今儿买了  前一天持有了 未操作
            dp1 = Math.max(dp0-prices[i],dp1);
        }
        // 返回 最后是未持有赚的多
        return dp0;
        
    }
}
```

### [附加题Leetcode309最佳买卖股票时机包含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

> 初试状态分为：持有，未持有冷冻期 未持有未冷冻期

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 当前股票状态的认识
        //持有股票  未持有股票处于冷冻期  未持有股票不处于冷冻期
        int dp0 = -prices[0];
        int dp1 = Integer.MIN_VALUE;
        int dp2 = 0;
        // 开始转移方程
        for(int i=1;i<prices.length;i++){
            // 持有股票=前一天持有了，前一天未持有不处于冷冻期买入
            int newdp0 = Math.max(dp0,dp2-prices[i]);
            // 未持有股票处于冷冻期=前一天相同的状态，前一天有股票刚卖了
            int newdp1 =  Math.max(dp1,dp0+prices[i]);
            // 未持有股票不处于冷冻期=前一天相同的状态，前一天未持有股票处于冷冻期
            int newdp2 = Math.max(dp1,dp2);
            // 重新复制
            dp0 = newdp0;
            dp1 = newdp1;
            dp2 = newdp2;
        }
        // 最后判断两个未持有
        return Math.max(dp1,dp2);
    }
}
```

### [附加题Leetcode714买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

> 解题思路：同Leetcode122

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        // 买卖股票包含手续费与之前的多次买卖相同
        // 当前的状态 持有 未持有
        int dp0 = -prices[0];
        int dp1 = 0;
        // 对其遍历
        for(int i=1;i<prices.length;i++){
            // 新的一天持有=前一天的持有 或者是未持有今儿买了
            int newdp0 = Math.max(dp0,dp1-prices[i]);
            // 新的一天未持有=前一天的持有卖了 或者是前一天未持有
            int newdp1 = Math.max(dp1,dp0+prices[i]-fee);

            dp0 = newdp0;
            dp1 = newdp1;
        }
        return dp1;
    }
}
```

### [附加题 Leetcode123买卖股票的最佳时机III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

> 解题思路：两次交易拆分成5个状态，且不能新建变量，初始化的时候不存在的要赋值最小值。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length<=1){
            return 0;
        }
        // 最多进行两次交易，共有5种状态
        // 未持有
        int dp0 = 0;
        // 第一次持有了
        int dp1 = -prices[0];
        // 第一次的未持有
        int dp2 =  Integer.MIN_VALUE;
        // 第二次的持有了
        int dp3 = Integer.MIN_VALUE;
        // 第二次的未持有
        int dp4 = Integer.MIN_VALUE;
        // 转移方程
        for(int i=1;i<prices.length;i++){
            // 一直未持有
            dp0 = 0;
            // 第一次持有=前一天的未持有/前一天的持有了
            dp1 = Math.max(dp1,dp0-prices[i]);
            // 第一次未持有=前一天的未持有/前一天的持有卖了
            dp2 = Math.max(dp2,dp1+prices[i]);
            // 第二次持有=一直持有 第一次未持有买了            
            dp3 = Math.max(dp3,dp2-prices[i]);
            // 第二次未持有=一直未持有，第一天持有卖了
            dp4 = Math.max(dp4,dp3+prices[i]);

            
        }

        //
        return Math.max(dp2,dp4);
    }
}
```

### [附加题 Leetcode188买卖股票的最佳时机IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2：

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

> 解题思路：

```java
class Solution {
    public int maxProfit(int K, int[] prices) {
        // 第几天 是否持有 交易的次数
        int n = prices.length;
        if(n<=1){
            return 0;
        }
        K = Math.min(K,n/2);
        // 数组赋值 
        int[][][] dp = new int[n][2][K+1];
        // 第一天
        for(int k=0;k<=K;k++){
            // 未持有
            dp[0][0][k] = 0 ;
            // 持有
            dp[0][1][k] = -prices[0];
        }

        // 其余
        for(int i=1;i<n;i++){
            for(int k=1;k<=K;k++){
                // 未持有=前一天未持有 前一天持有了卖了
                dp[i][0][k] = Math.max(dp[i-1][0][k],dp[i-1][1][k]+prices[i]);
                // 持有=前一天持有 前一天未持有 今儿买了
                dp[i][1][k] = Math.max(dp[i-1][1][k],dp[i-1][0][k-1]-prices[i]);
            }
        }
        return dp[n-1][0][K];
    }
}
```

### [51.Leetcode136只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1

示例 2:

输入: [4,1,2,1,2]
输出: 4

> 解题思路：
>
> 用异或运算符，就可以找到出现过一次的了
>
> 异或运算符可以满足交换律；
>
> 异或运算符本身与本身异或为0
>
> 异或运算符0与一个数的异或 还是一个数本身

```java
class Solution {
    public int singleNumber(int[] nums) {
        // 用异或运算符
        int res = 0;
        for(int num:nums){
            res^=num;
        }        
        return res;
    }
}
```

### [附加题：剑指Offer 03 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

> 解题思路：注意长度为n，数字为0-n-1之间。
>
> 采用的思路：原地排序+指针 for循环 + while指针

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        // 原地排序 + 指针
        for(int i=0;i<nums.length;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                // 交换
                int temp = nums[i];
                nums[i]   = nums[temp];
                nums[temp] = temp;
            }

        }
        return -1;
    }
}
```

### [附加题 Leetcode139单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

> 单词拆分计算true还是false，用背包问题的思路

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 背包问题
        int target = s.length();
        // 初始化
        boolean[] dp = new boolean[target+1];
        dp[0] = true;
        // 单词拆分有顺序
        for(int i=1;i<=target;i++){
            for(String word:wordDict){
                int len = word.length();
                // 判断
                if(len<=i&&word.equals(s.substring(i-len,i))){
                    dp[i] = dp[i] || dp[i-len];
                }
            }
        }
        return dp[target];
    }
}
```



### [52.Leetcode140单词拆分II](https://leetcode-cn.com/problems/word-break-ii/)

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]

> 解题思路：dfs

```java
class Solution {
    // 结果
    List<String> res = new ArrayList<>();
    public List<String> wordBreak(String s, List<String> wordDict) {
        // 临时值
        ArrayList<String> list = new ArrayList<>();
        // 将其转换为数组
        char[] arr = s.toCharArray();
        // 回溯
        dfs(arr,0,wordDict,list);
        return res; 
    }
    // 开始
    public void dfs(char[] arr,int index,List<String> wordDict,ArrayList<String> list){
        if(index==arr.length){
            // 符合条件
            StringBuilder temp = new StringBuilder();
            // 对其遍历
            for(String word:list){
                temp.append(word);
                temp.append(" ");
            }
            String temp_s = temp.toString();
            res.add(temp_s.substring(0,temp_s.length()-1));
        }
        if(index>arr.length){
            // 提前截止
            return;
        }
        for(String word:wordDict){
            int len = word.length();
            // 符合条件
            if(index+len<=arr.length&&new String(arr,index,len).equals(word)){
                list.add(new String(arr,index,len));
                dfs(arr,index+len,wordDict,list);
                list.remove(list.size()-1);
            }

        }

    }
}
```

### [53.Leetcode141环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。



进阶：

你能用 O(1)（即，常量）内存解决此问题吗？

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

> 解题思路：快慢指针来解题

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 判断是否有环
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            // 看是否相遇
            if(fast==slow){
                return true;
            }

        }
        return false;
    }
}
```

### [54.Leetcode142环形链表II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：

你是否可以使用 O(1) 空间解决此题？


示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

> 解题思路：快慢指针，相遇一起走

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 解题思路：快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            // 有环 相遇
            if(slow==fast){
                // 相遇之后
                fast = head;
                while(slow!=fast){
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```

### [55.Leetcode143重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.

示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

> 辅助结构 arraylist

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
       // 辅助结构
       List<ListNode> list = new ArrayList<>();
       // 对其放入
       ListNode node = head;
       while(node!=null){
           list.add(node);
           node = node.next;
       }
        // 对其遍历重新赋值
        int l = 0;
        int r = list.size()-1;
        while(l<r){
            // 开始连接
            list.get(l).next = list.get(r);
            l++;

            if(l==r){
                break;
            }
            list.get(r).next = list.get(l);
            r--;
        }
        // 最后为null
        list.get(l).next = null;

    }
}
```

> 多个方法的整合题

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        // 1.找中间的结点
        ListNode mid = findMiddle(head);
        // 2.划分两个结点
        ListNode after = mid.next;
        // 使其指针置为null
        mid.next = null;
        // 使后面那个链表翻转
        after = reverse(after);
        // 3.使前面那个链表和后面那个链表合并
        merge(head,after);
    }

    // 找中间的点
    public ListNode findMiddle(ListNode head){
        // 快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    // 翻转
    public ListNode reverse(ListNode cur){
        ListNode pre = null;
        ListNode next = null;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }        
        return pre;
    }

    // 合并
    public void merge(ListNode before,ListNode after){
        // 合并
        ListNode next1;
        ListNode next2;
        while(before!=null&&after!=null){
            next1 = before.next;
            next2 = after.next;

            before.next = after;
            before = next1;

            after.next = before;
            after = next2;

        }

    }
}
```

### [56.Leetcode144前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

> 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 结果
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root==null){
            return res;
        }
        res.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);

        return res;
    }
}
```

> 非递归 栈的方法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 结果
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root==null){
            return res;
        }

        // 前序遍历 前中后
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            res.add(root.val);

            if(root.right!=null){
                stack.push(root.right);
            }

            if(root.left!=null){
                stack.push(root.left);
            }
        }
        return res;
    }
}
```

### [57.Leetcode57 145二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定一个二叉树，返回它的 后序 遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

> 递归方法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 结果
    List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        // 后序遍历
        if(root==null){
            return res;
        }
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        res.add(root.val);

        return res;
    }
}
```

> 迭代的方法 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 根 右 左  左 右 根
    // 结果
    List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root==null){
            return res;
        }
        // 对其遍历
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        s1.push(root);
        while(!s1.isEmpty()){
            root = s1.pop();
            s2.push(root);
            if(root.left!=null){
                s1.push(root.left);
            }
            if(root.right!=null){
                s1.push(root.right);
            }
        }
        while(!s2.isEmpty()){
            res.add(s2.pop().val);
        }
        return res;

    }
}
```

### [58.Leetcode146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4

> 解题思路一：直接继承LinkedHashMap

```java
class LRUCache extends LinkedHashMap<Integer,Integer>{
    // 变量
    private int capacity;
    public LRUCache(int capacity) {
        super(capacity,0.75F,true);
        this.capacity = capacity;
    }
    
    public int get(int key) {
        return super.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        super.put(key,value);
    }  

    // 重写淘汰策略
    public boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){
        return size()>capacity;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

> hashMap与双向链表结合实现，
>
> 放入都放入，hashMap放入，双向链表放入
>
> 删除都删除，hashMap删除，双向链表删除
>
> 放入记得更新

```java
class LRUCache {
    // hashMap+双向链表
    // 变量
    class DLinkedList{
        int key;
        int value;
        DLinkedList prev;
        DLinkedList next;
        DLinkedList(){

        }
        DLinkedList(int key,int value){
            this.key = key;
            this.value = value;
        }
    }
    private HashMap<Integer,DLinkedList> hashMap;
    // 双向链表维护两个哑结点
    private DLinkedList head;
    private DLinkedList tail;
    // 最大容量
    private int capacity;
    private int size;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head = new DLinkedList();
        tail = new DLinkedList();
        // 连接
        head.next = tail;
        tail.prev = head;
        
        hashMap = new HashMap<>();
        this.size = 0;
    }
    // 获取值
    public int get(int key) {
        DLinkedList node = hashMap.get(key);
        // 如果为空
        if(node==null){
            return -1;
        }else{
           
            moveToHead(node);
            return node.value;
        }
    }
    
    public void put(int key, int value) {
        // 放置该点
        DLinkedList node = hashMap.get(key);
        // 该点不存在则放置 该点存在则更新
        if(node==null){
            // 新建
            node = new DLinkedList(key,value);
            // 先给hashMap添加
            hashMap.put(key,node);
            // 新建结点添加到头结点
            addToHead(node);

            // 需要判断是否超出容量
            size++;
            if(size>capacity){
                // 删除尾结点的前一个
                DLinkedList res =removeTail();
                // hashMap 也要删除
                hashMap.remove(res.key);
                size--;
            }
            
        }else{
            node.value = value;
            moveToHead(node);
        }
    }

    // 删除该结点
    public void removeNode(DLinkedList node){
        DLinkedList prev = node.prev;
        DLinkedList next = node.next;

        prev.next = next;
        next.prev = prev;
    }
    // 添加到头结点
    public void addToHead(DLinkedList node){
        node.prev = head;
        node.next = head.next;

        head.next.prev = node;
        head.next = node;
    }
    // 移动结点
    public void moveToHead(DLinkedList node){
        removeNode(node);
        addToHead(node);
    }


    // 删除尾结点
    public DLinkedList removeTail(){
        DLinkedList res = tail.prev;
        removeNode(res);
        return res;
    }
    
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### [59.Leetcode148排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？


示例 1：

输入：head = [4,2,1,3]
输出：[1,2,3,4]

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

> 注意：null的地方换成tail，要不然通不过

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        // 归并排序
        if(head==null || head.next==null){
            return head;
        }

        return mergeSort(head,null);
    }

    // 归并排序
    public ListNode mergeSort(ListNode head,ListNode tail){
        if(head==null){
            return null;
        }
        // 递归截止条件
        if(head.next==tail){
            head.next = null;
            return head;
        }
        // 找中间的点
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=tail&&fast.next!=tail){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode mid = slow;
        // 递归
        ListNode left = mergeSort(head,mid);
        ListNode right = mergeSort(mid,tail);
        //合并
        ListNode sorted = merge(left,right);
        return sorted;
    }

    // 合并
    public ListNode merge(ListNode l1,ListNode l2){
        // 新的链表
        ListNode dummy = new ListNode(-1);
        ListNode l = dummy;
        while(l1!=null&&l2!=null){
            if(l1.val<=l2.val){
                l.next = l1;
                l1 = l1.next;
                l = l.next;
            }else{
                l.next = l2;
                l2 = l2.next;
                l = l.next;
            }
        }
        if(l1!=null){
            l.next = l1;
        }
        if(l2!=null){
            l.next = l2;
        }
        return dummy.next;
    }
}
```

### [60.Leetcode151翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给定一个字符串，逐个翻转字符串中的每个单词。

说明：

无空格字符构成一个 单词 。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。


示例 1：

输入："the sky is blue"
输出："blue is sky the"
示例 2：

输入："  hello world!  "
输出："world! hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

> 考察：字符串的常见一些操作
>
> trim()去除前后空格
>
> split()正则表达式来分割字符串 将转成数组
>
> join()数组拼接起来形成字符串

```java
class Solution {
    public String reverseWords(String s) {
        // 1.先去除前后的空格
        s = s.trim();
        // 2.正则表达式来分割字符串
        List<String> list = Arrays.asList(s.split("\\s+"));
        // 3.反转
        Collections.reverse(list);
        // 4.数组转成字符串
        return String.join(" ",list);
    }
}
```

> 用双端队列，以及left和right

```java
class Solution {
    public String reverseWords(String s) {
        // 自实现
        int left = 0;
        int right = s.length()-1;
        // 去除空格
        while(left<=right&&s.charAt(left)==' '){
            left++;
        }
        while(right>=left&&s.charAt(right)==' '){
            right--;
        }
        // 开始遍历
        // 双端队列
        Deque<String> queue = new LinkedList<>();
        // 单词
        StringBuilder word = new StringBuilder();
        while(left<=right){
            char c = s.charAt(left);
            // 如果是空格并且单词不为空
            if(word.length()!=0&&c==' '){
                // 加入
                queue.offerFirst(word.toString());
                // 置空
                word.setLength(0);
            }else if(c!=' '){
                word.append(c);
            }
            left++;
        }
        // 还有一个未拼接
        queue.offerFirst(word.toString());
        // 最后拼接
        return String.join(" ",queue);

    }
}
```

### [61.Leetcode152乘积最大数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

> 连续数组找乘积最大值，动态规划解题 且有正有负

```java
class Solution {
    public int maxProduct(int[] nums) {
        //解题思路：动态规划
        int n = nums.length;
        int[] maxNum = new int[n];
        int[] minNum = new int[n];
        // 初始化
        maxNum[0] = nums[0];
        minNum[0] = nums[0];
        // 结果
        int res = nums[0];
        // 转移方程
        for(int i=1;i<n;i++){
            maxNum[i] = Math.max(nums[i],Math.max(nums[i]*maxNum[i-1],nums[i]*minNum[i-1]));
            minNum[i] = Math.min(nums[i],Math.min(nums[i]*maxNum[i-1],nums[i]*minNum[i-1]));
            res = Math.max(res,maxNum[i]);
        }
        return res;
    }
}
```

### [62.Leetcod155最小栈](https://leetcode-cn.com/problems/min-stack/)

计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

> 最小栈由两个栈组成，一个正常，一个存储最小值，比其小的放入，比其大的就重新顶峰元素

```java
class MinStack {
    // 最小栈
    /** initialize your data structure here. */
    // 正常的一个栈 一个维护最小值
    private Stack<Integer> stack_data;
    private Stack<Integer> stack_min;
    public MinStack() {
        // 初始化
        this.stack_data = new Stack<>();
        this.stack_min = new Stack<>();
    }
    
    public void push(int x) {
        // 放入
        if(this.stack_min.isEmpty()){
            this.stack_min.push(x);
        }else if(this.stack_min.peek()>x){
            this.stack_min.push(x);
        }else if(this.stack_min.peek()<x){
            int min = this.stack_min.peek();
            this.stack_min.push(min);
        }

        this.stack_data.push(x);
    }
    
    public void pop() {
        this.stack_data.pop();
        this.stack_min.pop();
    }
    
    public int top() {
        return this.stack_data.pop();
    }
    
    public int getMin() {
        return stack_min.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### [63.Leetcode160相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

> 解题思路：用hashmap或者直接遍历即可

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 解题思路：增加空间可用hashMap
        // 解题思路：不增加空间
        ListNode l1 = headA;
        ListNode l2 = headB;
        int len1 = 0;
        int len2 = 0;
        while(l1!=null){
            l1 = l1.next;
            len1++;
        }
        while(l2!=null){
            l2 = l2.next;
            len2++;
        }
        // 对其重新
        if(len1>=len2){
            l1 = headA;
            l2 = headB;
        }else{
            l1 = headB;
            l2 = headA;
        }

        // A较长 A先走
        int len = Math.abs(len1-len2);
        for(int i=1;i<=len;i++){
            l1 = l1.next;
        }

        // 同时走
        while(l1!=l2){
            l1 = l1.next;
            l2 = l2.next;
        }
        return l1;

    }
}
```

### [64.Leetcode162寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

 

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

> 解题思路：判断

```java
class Solution {
    public int findPeakElement(int[] nums) {
        // 只有一个值
        if(nums.length==1){
            return 0;
        }
        // 峰值
        for(int i=0;i<nums.length;i++){
            if(i==0){
                if(nums[i]>nums[i+1]){
                    return i;
                }
                continue;
            }

            
            if(i==nums.length-1){
                if(nums[i]>nums[i-1]){
                    return i;
                }
                return -1;
            }

             // 其余的时候
            if(nums[i]>nums[i-1]&&nums[i]>nums[i+1]){
                return i;
            }
            
           
        }
        return -1;
    }
}
```

> 优化

```java
class Solution {
    public int findPeakElement(int[] nums) {
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]>nums[i+1]){
                return i;
            }
        }
        return nums.length-1;
    }
}
```

> 二分法

```java
class Solution {
    public int findPeakElement(int[] nums) {
        
        // 二分查找
        int l = 0;
        int r = nums.length-1;
        while(l<r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]>nums[mid+1]){
                r= mid;
            }else{
                l = mid + 1;
            }
        }
        return l;
    }
}
```

### [65.Leetcode167两数之和II-输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。


示例 1：

输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

> 双指针的思路

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // 解题思路：hashMap 或者指针
        // 双指针
        int left = 0;
        int right = numbers.length-1;
        while(left<=right){
            int sum = numbers[left] + numbers[right];
            if(sum==target){
                return new int[]{left+1,right+1};
            }else if(sum>target){
                right--;
            }else if(sum < target){
                left++;
            }
        }
        return new int[]{-1,-1};
    }
}
```

### [66.Leetcode169多数元素](https://leetcode-cn.com/problems/majority-element/)


给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

> 初级版本，直接排序

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 排序
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

> 进阶版本，考虑O(n)复杂度 可用哈希表

```java
class Solution {
    public int majorityElement(int[] nums) {
        // hashMap寻找
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(hashMap.containsKey(nums[i])){
                hashMap.put(nums[i],hashMap.get(nums[i])+1);
            }else{
                hashMap.put(nums[i],1);
            }
        }

        // 对hashMap遍历
        Map.Entry<Integer,Integer> major = null;
        for(Map.Entry<Integer,Integer> map:hashMap.entrySet()){
            // 如果为空
            if(major==null || map.getValue()>major.getValue()){
                major = map;
            }
        }
        return major.getKey();

    }
}
```

> 摩尔投票法即诸侯争霸

```java
class Solution {
    public int majorityElement(int[] nums) {
        int candatite = nums[0];
        int count = 1;
        for(int num:nums){
            if(count==0){
                candatite = num;
            }
            count += num==candatite?1:-1;
        }
        return candatite;
    }
}
```

### [67.Leetcode190颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

颠倒给定的 32 位无符号整数的二进制位。

 

示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

> 考察二进制的与运算，或运算，左移与右移的运算符

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        // 颠倒二进制位 输入的最后一个开始
        int res = 0;
        // 进行32次
        for(int i=0;i<32;i++){
            // res左移
            res = res<<1;
            // res的值为=n的最后一位|res
            res = n&1|res;
            // n右移
            n = n>>1;
        }
        return res;
    }
}
```

### [68.Leetcode198打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

> 解题思路：动态规划
>
> 只有一家就打劫该家；
>
> 存在两家就打劫多的；
>
> 多余两家，前一家打劫了，前两家未被打劫+当前

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int n = nums.length;
        // 动态规划 贪心思想
        int[] dp = new int[n];
        // 只有一家就打劫该家
        dp[0] = nums[0];
        // 有两家就打劫多的
        dp[1] = Math.max(nums[0],nums[1]);
        // 别的
        for(int i=2;i<nums.length;i++){
            // 转移方程前一家已经被打劫了
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        // 返回
        return dp[n-1];
    }
}
```

### [69.Leetcode199二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

> 解题思路：右视图 用层次遍历的方式

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 结果
    List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        // 如果为空
        if(root==null){
            return res;
        }
        //层次遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 放入
        queue.offer(root);
        int levelSize = 1;
        // 开始
        while(!queue.isEmpty()){
            root = queue.poll();
            if(levelSize==1){
                res.add(root.val);
            }
            levelSize--;

            if(root.left!=null){
                queue.offer(root.left);
            }

            if(root.right!=null){
                queue.offer(root.right);
            }

            if(levelSize==0){
                levelSize = queue.size();
            }
        }
        return res;
    }
}
```

### [70.Leetcode203移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：

输入：head = [], val = 1
输出：[]

> 解题思路：类似荷兰国旗问题，左边慢慢往里加入符合条件的

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 添加一个哑结点
        ListNode dummy = new ListNode(-1,head);
        // 指针
        ListNode node = dummy;
        while(head!=null){
            while(head!=null&&head.val==val){
                // 相同
                head = head.next;
            }
            node.next = head;
            node = node.next;
            if(head!=null){
                head = head.next;
            }
        }
        return dummy.next;
    }
}
```

### [71.Leetcode206反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

> 迭代方法

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 迭代的解决
        ListNode pre = null;
        ListNode next = null;
        while(head!=null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }        
        return pre;
    }
}
```

>  递归

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
       //递归终止条件是当前为空，或者下一个节点为空
		if(head==null || head.next==null) {
			return head;
		}
		//这里的cur就是最后一个节点
		ListNode cur = reverseList(head.next);
		//这里请配合动画演示理解
		//如果链表是 1->2->3->4->5，那么此时的cur就是5
		//而head是4，head的下一个是5，下下一个是空
		//所以head.next.next 就是5->4
		head.next.next = head;
		//防止链表循环，需要将head.next设置为空
		head.next = null;
		//每层递归函数都返回cur，也就是最后一个节点
		return cur;
    }
}
```

### [72.Leetcode209长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：

输入：target = 4, nums = [1,4,4]
输出：1

示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

> 含最少长度，含子数组
>
> 解题思路：滑动窗口

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 解题思路：有长度 有连续子数组 滑动窗口
        int left = 0;
        int right = 0;
        int n = nums.length;
        int minLength = nums.length+1;
        int tempSum = 0;
        while(right<n){
            tempSum += nums[right];
            while(tempSum>=target){
                // 记录长度
                minLength = Math.min(minLength,right-left+1);
                // 缩短
                tempSum -= nums[left];
                left++;
            }
            right++;
        }
        return minLength==nums.length+1?0:minLength;
    }
}
```

### [73.Leetcode215数组中的第k个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

> 解题思路：数据结构求第k个最大元素，用优先级队列，即最小堆。

> 复杂的方法是排序，找倒数第k个

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 建立最小的优先级队列
        PriorityQueue<Integer> min_queue = new PriorityQueue<>((a,b)->(a-b));
        // 先放入k个元素
        for(int i=0;i<k;i++){
            min_queue.offer(nums[i]);
        }
        // k个元素之后
        for(int i=k;i<nums.length;i++){
            // 比较
            if(nums[i]>min_queue.peek()){
                min_queue.poll();
                min_queue.offer(nums[i]);
            }
        }
        return min_queue.peek();
    }
}
```

### [74.Leetcode226翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转一棵二叉树。

示例：

输入：

 4

   /   \
  2     7
 / \   / \
1   3 6   9
输出：

 4

   /   \
  7     2
 / \   / \
9   6 3   1

> 解题思路：递归，递归截止条件，交换，左节点 右节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 递归截止条件
        if(root==null){
            return root;
        }
        // 交换
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

### [75.Leetcode234回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

> 解题思路：不难，但是在O(n)和O(1)的复杂度来实现。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        
        // O(n)的时间复杂度和O(1)的空间复杂度
        // 先去找中间的结点
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next!=null&&fast.next.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        // 中间的结点
        ListNode mid = slow;
        // 前面的结点
        ListNode h1 = head;
        ListNode h2 = mid.next;
        // 断开
        mid.next = null;
        // 第二段翻转
        ListNode pre = null;
        ListNode next = null;
        while(h2!=null){
            next = h2.next;
            h2.next = pre;
            pre = h2;
            h2 = next;
        }
        // 第二端开始
        h2 = pre;
        //开始比较
        while(h1!=null&&h2!=null){
            if(h1.val!=h2.val){
                return false;
            }
            h1 = h1.next;
            h2 = h2.next;
        }
        return true;
    }
}
```

### [76.Leetcode236二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)


给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

> 父子结点找公共的

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 层次遍历
        HashMap<TreeNode,TreeNode> hashMap = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            root = queue.poll();

            if(root.left!=null){
                hashMap.put(root.left,root);
                queue.offer(root.left);
            }

            if(root.right!=null){
                hashMap.put(root.right,root);
                queue.offer(root.right);
            }

        }
        // 不一定 走的步数一样 对其寻找共同的父节点
        Set<TreeNode> set = new HashSet<>();
        while(p!=null){
            set.add(p);
            p = hashMap.get(p);
        }
        while(q!=null){
            if(set.contains(q)){
                return q;
            }
            q = hashMap.get(q);
        }
        return null;

    }
}
```

### [77.Leetcode240搜索二维矩阵II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

> 解题思路：从上角开始

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m  = matrix.length-1;
        int n = matrix[0].length;
        int row_start = 0;
        int col_start = n-1;
        while(row_start<=m&&col_start>=0){
            if(matrix[row_start][col_start]==target){
                return true;
            }else if(matrix[row_start][col_start]>target){
                col_start--;
            }else if(matrix[row_start][col_start]<target){
                row_start++;
            }
        }
        return false;
    }
}
```

### [78.Leetcode257二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3

> 层次遍历的时候用两个队列，一个存储点，另外一个可以存储结点的值，得到其路径

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        // 层次遍历
        List<String> res = new ArrayList<>();
        // 双队列
        Queue<TreeNode> queue_node = new LinkedList<>();
        Queue<String>   queue_path = new LinkedList<>();
        // 对其遍历
        queue_node.offer(root);
        queue_path.offer(Integer.toString(root.val));
        while(!queue_node.isEmpty()){
            root = queue_node.poll();
            String str = queue_path.poll();
            // 叶子结点了
            if(root.left==null&&root.right==null){
                res.add(str);
            }

            if(root.left!=null){
                queue_node.offer(root.left);
                queue_path.offer(new StringBuilder(str).append("->").append(root.left.val).toString());
            }

            if(root.right!=null){
                queue_node.offer(root.right);
                queue_path.offer(new StringBuilder(str).append("->").append(root.right.val).toString());

            }
        }
        return res;

    }
   
}
```

### [79.Leetcode283移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

> 移动零 荷兰国旗问题，两个值两个同时动，一个值动 一个值不动
>
> 知道都是零了，直接覆盖后面

```java
class Solution {
    public void moveZeroes(int[] nums) {
        // 等于0的移动到数组的末尾，保持非零元素的相对顺序
        int less = -1;
        int R = nums.length;
        int L = 0;
        while(L<R){
            if(nums[L]!=0){
                //交换
                swap(nums,++less,L++);
            }else if(nums[L]==0){
                L++;
            }
        }
    }

    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [80.Leetcode287寻找重复数字](https://leetcode-cn.com/problems/find-the-duplicate-number/)

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

 

示例 1：

输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3
示例 3：

输入：nums = [1,1]
输出：1

> 重复的数字，缺失的数字，原地排序

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        // 对其遍历
        for(int i=0;i<n;i++){
            while(i!=nums[i]-1){
                if(nums[i]==nums[nums[i]-1]){
                    return nums[i];
                }
                // 交换
                swap(nums,i,nums[i]-1);
            }
        }
        return -1;
    }
    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [81.Leetcode300最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

> 解题思路：动态规划

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 贪心算法
        int len = nums.length;
        //动态数组
        int[] dp = new int[len];
        dp[0] = 1;
        // 结果
        int res = 1;
        // 对剩下的遍历
        for(int i=1;i<nums.length;i++){
            dp[i] = 1;
            // 对其余遍历
            for(int j=0;j<i;j++){
                //看是否递增
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

> 解题思路：O(nlogn)的思路，用贪心+二分查找

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 贪心+二分查找
        // 存储最长递增子序列的数组
        int n = nums.length;
        int[] dp = new int[n+1];
        int len = 1;
        // 初始化
        dp[len] = nums[0];
        // 对其转移方程
        for(int i=1;i<n;i++){
            if(nums[i]>dp[len]){
                // 直接放入
                dp[++len] = nums[i];
            }else{
                int l =1;
                int r = len;
                int pos = 0;
                while(l<=r){
                    int mid = l +((r-l)>>1);
                    if(dp[mid]<nums[i]){
                        l = mid+1;
                        pos = mid;
                    }else{
                        r = mid-1;
                    }
                }
                // 最后赋值
                dp[pos+1] = nums[i]; 
            }
        }
        return len;
    }
}
```

### [82.Leetcode322零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

 

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

示例 2：

输入：coins = [2], amount = 3
输出：-1

> 解题思路：完全背包问题，重复拿取属于其中的最大最小问题
>
> 完全背包-最大最小问题

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 背包问题 从里面取找其最少的数量
        int[] dp = new int[amount+1];
        //初始化
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        // 完全背包问题恰好等于amount
        for(int coin:coins){
            for(int i=coin;i<=amount;i++){
                // 转移方程
                dp[i] = Math.min(dp[i],dp[i-coin]+1);
            }
        }        
        // 返回结果
        return dp[amount]==amount+1?-1:dp[amount];
    }
}
```

### [附加题83.Leetcode518 零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

 

示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。

> 背包问题，可重复
>
> 完全背包-组合个数问题

```java
class Solution {
    public int change(int amount, int[] coins) {
        // 背包问题
        int[] dp = new int[amount+1];
        // 初始化
        dp[0] = 1;
        for(int coin:coins){
            for(int j=coin;j<=amount;j++){
                dp[j] = dp[j] + dp[j-coin];
            }
        }
        return dp[amount];
    }
}
```

### [附加题139单词拆分](https://leetcode-cn.com/problems/word-break/)

### [附加题416分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/)

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].

> 转换该题的思路

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 是否可以分割，即两个和是否相等
        int sum = 0;
        for(int num:nums){
            sum += num;
        }
        // 判断
        if(sum%2==1){
            return false;
        }
        int target = sum/2;
        // 动态规划
        boolean[] dp = new boolean[target+1];
        dp[0] = true;
        // 即从背包一次取出一样，来判断是否等于target
        for(int num:nums){
            for(int j=target;j>=num;j--){
                // 转移方程
                dp[j] = dp[j] || dp[j-num];
            }
        }
        // 返回
        return dp[target];
    }
}
```

### [附加题377组合总和IV](https://leetcode-cn.com/problems/combination-sum-iv/)

定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

> 有顺序的问题-完全背包问题-组合问题

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // 动态规划 背包问题
        int[] dp = new int[target+1];
        // 初始化
        dp[0] = 1;
        // 转移方程
        // 有顺序
        for(int i=1;i<=target;i++){
            for(int num:nums){
                // 加判断条件
                if(i>=num){
                     dp[i] = dp[i] + dp[i-num];
                }
            }
        }
        return dp[target];
    }
}
```

### [附加题494目标和](https://leetcode-cn.com/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

> 求次数，只用一次都用上了

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        // 将其转换为背包问题
        // x+y=sum  x-y = s 即找出一部分的值等于(sum+s)/2
        int sum = 0;
        for(int num:nums){
            sum+=num;
        }
        if(sum<S||(sum+S)%2==1){
            return 0;
        }
        int target = (sum+S)/2;
        //开始从
        // 动态规划
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int num:nums){
            for(int j=target;j>=num;j--){
                dp[j] = dp[j] + dp[j-num];
            }
        }
        return dp[target];
    }
}
```

### [附加题 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // 背包问题
        int[][] dp = new int[m+1][n+1];
        // 求最大的集合问题
        for(String s:strs){
            // 转换为数组
            char[] arr = s.toCharArray();
            // 对其遍历统计当前
            int zeros = 0;
            int ones = 0;
            for(int i=0;i<arr.length;i++){
                if(arr[i]=='0'){
                    zeros++;
                }
                if(arr[i]=='1'){
                    ones++;
                }
            }
            //只用一次
            for(int i=m;i>=zeros;i--){
                for(int j=n;j>=ones;j--){
                    // 转移方程
                    dp[i][j] = Math.max(dp[i][j],dp[i-zeros][j-ones]+1);
                }
            }
        }
        return dp[m][n];

    }
}
```

### [83.Leetcode347 前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]

> 时间复杂度优于O(nlog)
>
> 用HashMap和PriorityQueue<>辅助解题

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 用优先级队列结合HashMap
        // hashmap存储这个值和次数
        // 优先级队列获取次数
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for(int num:nums){
            hashMap.put(num,hashMap.getOrDefault(num,0)+1);
        }
        // 优先级队列存储键 比较通过hashMap 最小堆
        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->(hashMap.get(a)-hashMap.get(b)));
        // 开始对hashMap遍历 entrySet keySet valueSet
        for(int key:hashMap.keySet()){
            // 以便往queue里面放入值
            if(queue.size()<k){
                // 如果里面的值小于直接放入
                queue.offer(key);
            }else{
                if(hashMap.get(key)>hashMap.get(queue.peek())){
                    // 排出来
                    queue.poll();
                    queue.offer(key);
                }
            }            
        }
        // 对priorityqueue排出来
        int[] res = new int[k];
        for(int i=k-1;i>=0;i--){
            res[i] = queue.poll();
        }
        return res;

    }
}
```

### [84.Leetcode394字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

 

示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"

> 解题思路：
>
> 两个栈，一个栈存储数字，一个栈存储字符串
>
> 数字的话记录当前的值记得*10
>
> 字符串就append
>
> 入栈之后都其全部初始化
>
> 出栈都是临时值并重新赋值对字符串

```java
class Solution {
    public String decodeString(String s) {
        // 数据编码 记住就会，记不住就不会
        // 两个栈 一个栈存储数据，另外一个栈存储字符串
        Stack<Integer> stack_num = new Stack<>();
        Stack<StringBuilder> stack_str = new Stack<>();
        // 数字
        int curNum = 0;
        StringBuilder resChar = new StringBuilder();
        // 对其遍历
        for(Character c:s.toCharArray()){
            // 判断是数字的话
            if(Character.isDigit(c)){
                curNum = curNum*10 + c-'0';
            }else if(Character.isAlphabetic(c)){
                resChar.append(c);
            }else if(c=='['){
                // 入栈
                stack_num.push(curNum);
                stack_str.push(resChar);
                // 重新赋值
                curNum = 0;
                resChar = new StringBuilder();
            }else if(c==']'){
                // 出栈计算
                int tempNum = stack_num.pop();
                StringBuilder tempChar = stack_str.pop();
                // 计算
                for(int i=0;i<tempNum;i++){
                    tempChar.append(resChar);
                }
                resChar = tempChar;
            }
        }
        return resChar.toString();
    }
}
```

### [85.Leetcode415字符串相加](https://leetcode-cn.com/problems/add-strings/)

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

 

提示：

num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

> 字符串相加 ||

```java
class Solution {
    public String addStrings(String num1, String num2) {
        // 第一步转换成数组
        char[] num1_arr = num1.toCharArray();
        char[] num2_arr = num2.toCharArray();
        int len1 = num1_arr.length;
        int len2 = num2_arr.length;
        // 第二步结果拼接
        StringBuilder res = new StringBuilder();
        // 进位
        int mod = 0;
        // 开始
        int index_1 = len1-1;
        int index_2 = len2-1;
        while(index_1>=0||index_2>=0){
            // 当前数值
            int cur_1 = index_1<0?0:num1_arr[index_1] - '0';
            int cur_2 = index_2<0?0:num2_arr[index_2] - '0';
            // 相加
            int temp_sum = cur_1 + cur_2 + mod;
            res.append(temp_sum%10);
            // 更新进位
            mod = temp_sum/10;
            // 继续移动
            index_1--;
            index_2--;
        }
       // 如果最后余数不为0
       if(mod!=0){
           res.append(mod);
       }
        // 翻转

        return  res.reverse().toString();
    }
}
```

### [86.Leetcode445两数相加II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

 

进阶：

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

 

示例：

输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7

> 用数组来存储

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 用arraylist来存储
        ArrayList<Integer> list_1 = new ArrayList<>();
        ArrayList<Integer> list_2 = new ArrayList<>();
        // 对其遍历
        int len_1 = 0;
        int len_2 = 0;
        while(l1!=null){
            len_1++;
            list_1.add(l1.val);
            l1 = l1.next;
        }
        while(l2!=null){
            len_2++;
            list_2.add(l2.val);
            l2 = l2.next;
        }
        int index_1 = len_1-1;
        int index_2 = len_2-1;
        int mod = 0;
        // 新链表
        ListNode node = null;
        while(index_1>=0 || index_2>=0){
            // 当前值
            int cur_1 = index_1<0?0: list_1.get(index_1);
            int cur_2 = index_2<0?0: list_2.get(index_2);
            // 总和
            int temp_sum = cur_1 + cur_2 + mod;
            // 计算
            mod = temp_sum/10;
            // 新节点
            if(node==null){
                // 第一个尾结点
                node = new ListNode(temp_sum%10);
            }else{
                ListNode newNode = new ListNode(temp_sum%10);
                newNode.next = node;
                // node重新移动
                node = newNode;
            }
 
            //继续走
            index_1--;
            index_2--;
        }
        //如果还有进位
        if(mod!=0){
            ListNode newNode = new ListNode(mod);
            newNode.next = node;
            node = newNode;
        }
        return node;

    }
}
```

> 用栈来存储

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 刚好顺序反转就用栈
        Stack<Integer> s1 = new Stack<>();
        Stack<Integer> s2 = new Stack<>();
        // 入栈
        while(l1!=null){
            s1.push(l1.val);
            l1 = l1.next;
        }
        while(l2!=null){
            s2.push(l2.val);
            l2 = l2.next;
        }
        int mod = 0;
        // 结果
        ListNode node = null;
        while(!s1.isEmpty()||!s2.isEmpty()){
            int cur1 = s1.isEmpty()?0:s1.pop();
            int cur2 = s2.isEmpty()?0:s2.pop();
            // 加法
            int sum = cur1+cur2+mod;
            // 计算进位
            mod = sum/10;
            // 新链表
            ListNode newNode = new ListNode(sum%10);
            newNode.next = node;
            node = newNode;
        }
        // 如果还有余数
        if(mod!=0){
            ListNode newNode = new ListNode(mod);
            newNode.next = node;
            node = newNode;
        }
        return node;


    }
}
```

### [87.Leetcode460 LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)

请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

实现 LFUCache 类：

LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。
void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。
注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

 

示例：

输入：
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
输出：
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

解释：
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lFUCache = new LFUCache(2);
lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1
lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lFUCache.get(1);      // 返回 1
                      // cache=[1,2], cnt(2)=1, cnt(1)=2
lFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                      // cache=[3,1], cnt(3)=1, cnt(1)=2
lFUCache.get(2);      // 返回 -1（未找到）
lFUCache.get(3);      // 返回 3
                      // cache=[3,1], cnt(3)=2, cnt(1)=2
lFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                      // cache=[4,3], cnt(4)=1, cnt(3)=2
lFUCache.get(1);      // 返回 -1（未找到）
lFUCache.get(3);      // 返回 3
                      // cache=[3,4], cnt(4)=1, cnt(3)=3
lFUCache.get(4);      // 返回 4
                      // cache=[3,4], cnt(4)=2, cnt(3)=3

> 两个hashMap，一个存储键值对 ；另外一个双向链表存储频率和该结点

```java
class LFUCache {
    Map<Integer, Node> cache;  // 存储缓存的内容
    Map<Integer, LinkedHashSet<Node>> freqMap; // 存储每个频次对应的双向链表
    int size;
    int capacity;
    int min; // 存储当前最小频次

    public LFUCache(int capacity) {
        cache = new HashMap<> (capacity);
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            freqInc(node);
        } else {
            if (size == capacity) {
                Node deadNode = removeNode();
                cache.remove(deadNode.key);
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            size++;     
        }
    }

    void freqInc(Node node) {
        // 从原freq对应的链表里移除, 并更新min
        int freq = node.freq;
        LinkedHashSet<Node> set = freqMap.get(freq);
        set.remove(node);
        if (freq == min && set.size() == 0) { 
            min = freq + 1;
        }
        // 加入新freq对应的链表
        node.freq++;
        LinkedHashSet<Node> newSet = freqMap.get(freq + 1);
        if (newSet == null) {
            newSet = new LinkedHashSet<>();
            freqMap.put(freq + 1, newSet);
        }
        newSet.add(node);
    }

    void addNode(Node node) {
        LinkedHashSet<Node> set = freqMap.get(1);
        if (set == null) {
            set = new LinkedHashSet<>();
            freqMap.put(1, set);
        } 
        set.add(node); 
        min = 1;
    }

    Node removeNode() {
        LinkedHashSet<Node> set = freqMap.get(min);
        Node deadNode = set.iterator().next();
        set.remove(deadNode);
        return deadNode;
    }
}

class Node {
    int key;
    int value;
    int freq = 1;

    public Node() {}
    
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}


```

### [88.Leetcode480滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

> 滑动窗口中位数

> // 维护一个排序的滑动窗口
>
> // 求中间数
>
> // 求之前的数删除，替换成新添加的
>
> // 重新排序

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        // 1.维护一个排过序的滑动窗口数组
        // 2.使用二分查找检索删除的索引
        // 3.将需要删除的值替换为需要插入的值
        // 4.使用局部冒泡排序保证数组顺序
        int len = nums.length;
        int[] windows = new int[k];
        // 结果
        double[] res = new double[len-k+1];
        //给初始化的滑动窗口赋值
        for(int i=0;i<k;i++){
            windows[i] = nums[i];
        }
        // 对其排序
        Arrays.sort(windows);
        // 二分查找中间的值
        res[0] = getMid(windows);
        // 遍历其它的
        for(int i=0;i<len-k;i++){
            // 获取要删除的索引
            int index = binarySearch(windows,nums[i]);
            // 删除即替换
            windows[index] = nums[i+k];
            // 重新排序
            while(index<windows.length-1&&windows[index]>windows[index+1]){
                // 交换
                swap(windows,index,index+1);
                index++;
            }
            while(index>0&&windows[index]<windows[index-1]){
                swap(windows,index,index-1);
                index--;
            }
            // 重新寻找中位数
            res[i+1] = getMid(windows);
        }
        // 返回其值
        return res;
    }

    // 交换
    public void swap(int[] windows,int left,int right){
        int temp = windows[left];
        windows[left] = windows[right];
        windows[right] = temp;
    }
    // 二分查找
    public int binarySearch(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            // 判断
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
               l = mid+1; 
            }
        }
        return -1;
    }

    // 求数组的中位数
    public double getMid(int[] windows){
        int len = windows.length;
        if(len%2==0){
            // 避免溢出
            return windows[len/2]/2.0 +windows[len/2-1]/2.0;
        }else{
            return windows[len/2];
        }
    }
}
```

### [89.Leetcode543二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

> 解题思路：求二叉树的高度中穿插

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null){
            return 0;
        }
        // 递归
        dfs(root);
        return max;
    }
    // 求高度
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int leftSize = dfs(root.left);
        int rightSize = dfs(root.right);
        // 更新直径
        max = Math.max(max,leftSize+rightSize);

        return Math.max(leftSize,rightSize) +1;

    }
}
```

### [补充题: Leetcode687最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:

2

> 解题思路：深度优先搜索dfs递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int max_path = 0;
    public int longestUnivaluePath(TreeNode root) {
        // 当前值出发
        if(root==null){
            return 0;
        }
        dfs(root,root.val);
        return max_path;
    }
    // 深度优先搜索
    public int dfs(TreeNode root,int val){
        if(root==null){
            return 0;
        }
        int left = dfs(root.left,root.val);
        int right = dfs(root.right,root.val);
        max_path = Math.max(max_path,left+right);

        if(root.val==val){
            return Math.max(left,right) + 1; 
        }
        return 0;

    }
}
```



### [补充题：剑指offer55-I 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        return dfs(root);
    }
    // 递归
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int leftSize = dfs(root.left);
        int rightSize = dfs(root.right);

        // 高度

        return Math.max(leftSize,rightSize) +1;
    }
}
```

### [补充题：二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)


输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 初始化的值
    int max_num = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {

        dfs(root);
        return max_num;
    }
    // 针对当前结点
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        // 可能存在负数
        int leftSum = Math.max(0,dfs(root.left));
        int rightSum = Math.max(0,dfs(root.right));
        // 更新值
        max_num = Math.max(max_num,root.val+leftSum+rightSum);

        return root.val + Math.max(leftSum,rightSum);

    }
}
```

### [90.Leetcode560和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。

> 解题思路：从开始的值，第二个循环end的值

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 暴力求解
        int count = 0;
        int len = nums.length;
        for(int start=0;start<len;start++){
            int sum = 0;
            // 逆序
            for(int end=start;end>=0;end--){
                sum+= nums[end];
                if(sum==k){
                    count++;
                }
            }
        }
        return count;
    }
}
```

> 优化是前缀和，即hashMap的两数之和的思路

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 前缀和前缀 次数
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        // 存放值
        hashMap.put(0,1);
        // 次数
        int count = 0;
        int preSum = 0;
        // 开始遍历
        for(int num:nums){
            preSum += num;
            // 存在就记录
            if(hashMap.containsKey(preSum-k)){
                // 记录
                count += hashMap.get(preSum-k);
            }

            // 放置并更新
            hashMap.put(preSum,hashMap.getOrDefault(preSum,0)+1);
        }
        return count;
    }
}
```

### [91.Leetcode662二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

示例 1:

输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。

> 解题思路：层次遍历，但是另外一种写法，两个while的写法，并且需要修改root.val为index索引，通过索引更新宽度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        // 宽度
        int width = 0;
        // 根节点
        root.val = 0;
         // 层次遍历解题
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        // 求宽度，计算索引
        while(!queue.isEmpty()){
            int levelSize = queue.size();
            width = Math.max(width,queue.getLast().val-queue.getFirst().val+1);
            while(levelSize>0){
                root = queue.poll();
                if(root.left!=null){
                    root.left.val = root.val * 2 + 1;
                    queue.offer(root.left);
                }
                if(root.right!=null){
                    root.right.val = root.val * 2 + 2;
                    queue.offer(root.right);
                }
                levelSize--;
            }
        }

        return width;
    }
}
```

### [92.Leetcode958二叉树的完全性校验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

给定一个二叉树，确定它是否是一个完全二叉树。

百度百科中对完全二叉树的定义如下：

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）

 

示例 1：



输入：[1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。

> 层次遍历, 并用一个leaf来表示是否为叶子结点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        // 解题思路 层次遍历
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        // 判断当前节点是否为叶子
        boolean leaf = false;
        // 开始遍历
        while(!queue.isEmpty()){
            root = queue.poll();
            if(leaf&&!isLeaf(root)){
                return false;
            }
            if(root.left!=null){
                queue.offer(root.left);
            }else if(root.right!=null){
                return false;
            }

            if(root.right!=null){
                queue.offer(root.right);
            }else{
                leaf = true;
            }

        }
        return true;
    }

    // 判断是否叶子结点
    public boolean isLeaf(TreeNode root){
        return root.left==null&&root.right==null;
    }
}
```

### [93.Leetcode_Offer09 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

 

示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]

示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]

>解题思路：两个栈模拟队列
>
>入栈直接入；
>
>出栈不为空则出，为空，则把入栈都给借过来

```java
class CQueue {
    // 两个栈模拟队列
    // 入队：直接进in_stack
    // 出队：为空和不为空 为空则将in_stack全部进output，弹出来一个；不为空则直接弹出来
    Stack<Integer> in_stack;
    Stack<Integer> output_stack;
    public CQueue() {
        in_stack = new Stack<>();
        output_stack = new Stack<>();
    }
    // 入队
    public void appendTail(int value) {
        in_stack.push(value);
    }
    // 出队
    public int deleteHead() {
        if(output_stack.isEmpty()){
            if(in_stack.isEmpty()){
                return -1;
            }
            while(!in_stack.isEmpty()){
                output_stack.push(in_stack.pop());
            }
            return output_stack.pop();
        }else{
            return output_stack.pop();
        }
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

### [附加题Leetcode225 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。


示例：

输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False

> 解题思路：两个队列模拟一个栈
>
> 入栈：入队列，都要过来
>
> 出栈：出即可

```java
class MyStack {
    // 队列模拟一个栈
    Queue<Integer> in_queue;
    Queue<Integer> out_queue;
    /** Initialize your data structure here. */
    public MyStack() {
        in_queue = new LinkedList<>();
        out_queue = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        // 先接收
        in_queue.offer(x);
        while(!out_queue.isEmpty()){
            in_queue.offer(out_queue.poll());
        }
        // 互换
        Queue<Integer> temp = in_queue;
        in_queue = out_queue;
        out_queue = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        // 弹出
        return out_queue.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return out_queue.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return in_queue.isEmpty()&&out_queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

### [94.Leetcode_Offer03 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)


找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

> 解题思路：原数组中排序

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        // 原数组中排序查找0-n-1之间
        for(int i=0;i<nums.length;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                // 交换
               swap(nums,i,nums[i]);
            }
        }
        // 最后返回
        return -1;
    }

    // 交换排序
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j] = temp;
    }
}
```

### [95.Leetcode_Offer21 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

 

示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。


提示：

0 <= nums.length <= 50000
1 <= nums[i] <= 10000

```java
class Solution {
    public int[] exchange(int[] nums) {
        int less = -1;
        int L = 0;
        int R = nums.length;
        while(L<R){
            if((nums[L]%2)!=0){
                // 奇数
                swap(nums,++less,L++);
            }else{
                // 偶数
                L++;
            }
        }
        return nums;
    }
    //交换顺序
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [96.Leetcode_Offer36 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 

为了让您更好地理解问题，以下面的二叉搜索树为例：

 ![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)



 

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 ![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

> 解题思路：用数组来辅助解题

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    // 需要用到中序遍历
    // 用链表来辅助解题
    LinkedList<Node> list = new LinkedList<>();
    public Node treeToDoublyList(Node root) {
        if(root==null){
            return root;
        }
        // 开始遍历
        dfs(root);
        
        Node pre = list.removeFirst();
        root = pre;
        Node cur = pre;
        while(!list.isEmpty()){
            cur = list.removeFirst();
            cur.left = pre;
            pre.right = cur;
            pre = cur;
        }
        // 最后尾巴的连接
        cur.right = root;
        root.left = cur;
        return root;

    }

    // 中序遍历
    public void dfs(Node root){
        if(root==null){
            return;
        }
        dfs(root.left);
        list.add(root);
        dfs(root.right);

    }
}

```

> 中序遍历的过程中直接修改

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre,head;
    public Node treeToDoublyList(Node root) {
        if(root==null){
            return root;
        }
        // 中序遍历
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    // 中序遍历
    public void dfs(Node root){
        if(root==null){
            return;
        }
        dfs(root.left);
        // 当前节点处理
        if(pre==null){
            head = root;
        }else{
            pre.right = root;
        }
        root.left = pre;
        pre = root;

        dfs(root.right);
    }
}
```

### [97.Leetcode_Interview34二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

 

示例:
给定如下二叉树，以及目标和 target = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // hashMap存储 当前节点及其父节点
    HashMap<TreeNode,TreeNode> hashMap = new HashMap<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        
        // 结果
        List<List<Integer>> res = new LinkedList<>();
        if(root==null){
            return res;
        }
        // 层次遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 存储当前节点以及父节点相加的值
        Queue<Integer> queue_sum = new LinkedList<>();
        
        queue.offer(root);
        queue_sum.offer(root.val);
        hashMap.put(root,null);
        // 临时值
        int temp_sum = root.val;
        while(!queue.isEmpty()){
            root = queue.poll();
            temp_sum = queue_sum.poll();
            // 根节点处理
            if(root.left==null&&root.right==null){
                if(temp_sum==target){
                    // 处理路径
                    LinkedList list = path(root);
                    res.add(list);
                }
            }
            
            if(root.left!=null){
                queue.offer(root.left);
                queue_sum.offer(temp_sum+root.left.val);
                hashMap.put(root.left,root);
            }

            if(root.right!=null){
                queue.offer(root.right);
                queue_sum.offer(temp_sum+root.right.val);
                hashMap.put(root.right,root);
            }
        }
        return res;
    }

    // 路径
    public LinkedList<Integer> path(TreeNode root){
        LinkedList<Integer> list = new LinkedList<>();
        while(root!=null){
            list.add(root.val);
            root = hashMap.get(root);
        }
        // 翻转
        Collections.reverse(list);

        return list;
    }
}
```

